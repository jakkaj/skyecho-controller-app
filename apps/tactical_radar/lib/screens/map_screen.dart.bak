import 'dart:async';

import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:location/location.dart';
import 'package:skyecho_gdl90/skyecho_gdl90.dart';

import '../models/ownship_state.dart';
import '../models/traffic_target.dart';
import '../services/gdl_service.dart';

/// Map screen displaying ownship and traffic on Google Maps with rotated arrows.
///
/// Features:
/// - Google Maps with rotated arrow markers for ownship and traffic
/// - Ownship fallback: GDL90 → phone GPS (yellow marker if fallback)
/// - Traffic markers with altitude differentials and color coding
/// - Native marker rotation using Marker.rotation property
/// - App bar indicator: green (receiving GDL90), grey (disconnected)
/// - UI batching at 10 FPS (100ms intervals) per Discovery 05
/// - Debug logging enabled
class MapScreen extends StatefulWidget {
  const MapScreen({super.key});

  @override
  State<MapScreen> createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  // Services
  late GdlService _gdlService;
  final Location _location = Location();

  // Subscriptions
  StreamSubscription<Gdl90Message>? _messagesSub;
  StreamSubscription<bool>? _connectionSub;

  // UI state
  OwnshipState? _ownshipState;
  int? _ownshipBaroAltitude;
  Map<int, TrafficTarget> _trafficTargets = {};
  bool _isConnected = false;
  DateTime? _lastOwnshipTime;
  DateTime? _lastHeartbeatTime;
  bool _usingGpsFallback = false;
  bool _gpsRequestInProgress = false;

  // Batching state (Discovery 05: 10 FPS UI updates)
  Timer? _uiUpdateTimer;
  final List<Gdl90Message> _pendingMessages = [];

  // Map controller
  GoogleMapController? _mapController;

  // Cached arrow icons (loaded once from assets)
  BitmapDescriptor? _ownshipIcon;
  BitmapDescriptor? _trafficIcon;

  @override
  void initState() {
    super.initState();
    _loadMarkerIcons();
    _initializeGdl();
    _checkLocationPermission();
  }

  Future<void> _loadMarkerIcons() async {
    _ownshipIcon = await BitmapDescriptor.fromAssetImage(
      const ImageConfiguration(devicePixelRatio: 3.0),
      'assets/markers/arrow_green.png',
    );
    _trafficIcon = await BitmapDescriptor.fromAssetImage(
      const ImageConfiguration(devicePixelRatio: 3.0),
      'assets/markers/arrow_red.png',
    );
    if (mounted) setState(() {});
  }

  @override
  void dispose() {
    _messagesSub?.cancel();
    _connectionSub?.cancel();
    _uiUpdateTimer?.cancel();
    _gdlService.disconnect();
    _gdlService.dispose();
    super.dispose();
  }

  Future<void> _initializeGdl() async {
    _gdlService = GdlService();

    try {
      // Subscribe to streams BEFORE connecting to catch initial events
      _connectionSub = _gdlService.connectionStatus.listen((connected) {
        if (mounted) {
          setState(() {
            _isConnected = connected;
          });
        }
      });

      _messagesSub = _gdlService.messages.listen(_handleGdlMessage);

      // Now connect - this will emit initial connection status
      await _gdlService.connect();

      // Set initial connection state from service
      if (mounted) {
        setState(() {
          _isConnected = _gdlService.isConnected;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to connect to GDL90: $e')),
        );
      }
    }
  }

  Future<void> _checkLocationPermission() async {
    print('[PERMISSION] Starting location permission check...');

    try {
      print('[PERMISSION] Checking if location service is enabled...');
      final serviceEnabled = await _location.serviceEnabled();
      print('[PERMISSION] Service enabled: $serviceEnabled');

      if (!serviceEnabled) {
        print('[PERMISSION] Requesting location service...');
        final requested = await _location.requestService();
        print('[PERMISSION] Service request result: $requested');
        if (!requested) {
          print('[PERMISSION] Location service not enabled, aborting');
          return;
        }
      }

      print('[PERMISSION] Checking current permission status...');
      var permissionGranted = await _location.hasPermission();
      print('[PERMISSION] Current permission: $permissionGranted');

      if (permissionGranted == PermissionStatus.denied) {
        print('[PERMISSION] Permission denied, requesting permission...');
        permissionGranted = await _location.requestPermission();
        print('[PERMISSION] Permission request result: $permissionGranted');

        if (permissionGranted != PermissionStatus.granted) {
          print('[PERMISSION] Permission not granted, aborting');
          return;
        }
      }

      print('[PERMISSION] Location permission check complete - granted');
    } catch (e) {
      print('[PERMISSION] ERROR during permission check: $e');
    }
  }

  /// Handle incoming GDL90 messages with batching.
  ///
  /// Collects messages and updates UI at max 10 FPS (100ms intervals)
  /// to prevent frame drops per Discovery 05.
  void _handleGdlMessage(Gdl90Message message) {
    _pendingMessages.add(message);

    // Start timer if not already running
    _uiUpdateTimer ??= Timer(
      const Duration(milliseconds: 100),
      _flushPendingUpdates,
    );
  }

  /// Flush batched messages and update UI.
  void _flushPendingUpdates() {
    if (_pendingMessages.isEmpty || !mounted) {
      _uiUpdateTimer = null;
      return;
    }

    setState(() {
      for (final message in _pendingMessages) {
        _processMessageForUI(message);
      }
      _pendingMessages.clear();
    });

    _uiUpdateTimer = null;
  }

  /// Process individual message for UI state updates.
  void _processMessageForUI(Gdl90Message message) {
    // Debug logging
    print('[GDL90] ${message.messageType}: ${message.toString()}');

    switch (message.messageType) {
      case Gdl90MessageType.ownship:
        _handleOwnshipUpdate(message);
      case Gdl90MessageType.traffic:
        _handleTrafficUpdate(message);
      case Gdl90MessageType.heartbeat:
        _handleHeartbeat(message);
      default:
        break;
    }
  }

  void _handleOwnshipUpdate(Gdl90Message message) {
    final newState = OwnshipState.fromGdl90Message(message);
    _ownshipBaroAltitude = message.altitudeFeet;

    print('[OWNSHIP] lat=${message.latitude}, lon=${message.longitude}, '
        'alt=${message.altitudeFeet}, position=${newState.position}');

    // Only update ownship state if we have a valid position
    // This preserves last known position if GPS is temporarily lost
    if (newState.position != null) {
      _ownshipState = newState;
      _lastOwnshipTime = DateTime.now();
      _usingGpsFallback = false;
      print('[OWNSHIP] Updated to valid GDL90 position');

      // Center map on ownship if first valid position
      if (_mapController != null) {
        _mapController!.animateCamera(
          CameraUpdate.newLatLng(_ownshipState!.position!),
        );
      }
    } else {
      // No valid position from GDL90, trigger GPS fallback check
      // but keep showing last known position
      print('[OWNSHIP] No valid GDL90 position (keeping last known), checking GPS fallback');
      _checkGpsFallback();
    }
  }

  void _handleTrafficUpdate(Gdl90Message message) {
    final icao = message.icaoAddress;
    if (icao == null) return;

    try {
      final target = TrafficTarget.fromGdl90Message(
        message: message,
        ownshipAltitude: _ownshipBaroAltitude,
      );
      _trafficTargets[icao] = target;
      print('[TRAFFIC] ICAO: ${icao.toRadixString(16).toUpperCase()}, '
          'Callsign: ${target.callsign ?? "N/A"}, '
          'Alt: ${target.altitude}ft, '
          'RelAlt: ${target.relativeAltitude}');
    } catch (e) {
      // Skip traffic with invalid data
      print('[TRAFFIC] Error parsing ICAO $icao: $e');
    }
  }

  void _handleHeartbeat(Gdl90Message message) {
    _lastHeartbeatTime = DateTime.now();

    // Update GPS status if needed
    final hasGps = message.gpsPosValid ?? false;
    if (!hasGps && _ownshipState?.position == null) {
      // No GDL90 GPS, check for phone GPS fallback
      _checkGpsFallback();
    }
  }

  /// Check if GPS fallback is needed (no ownship for 5s).
  Future<void> _checkGpsFallback() async {
    // Prevent concurrent GPS requests
    if (_gpsRequestInProgress) {
      print('[GPS] GPS request already in progress, skipping');
      return;
    }

    print('[GPS] Checking fallback...');
    print('[GPS] _lastOwnshipTime: $_lastOwnshipTime');
    print('[GPS] Current time: ${DateTime.now()}');

    if (_lastOwnshipTime == null ||
        DateTime.now().difference(_lastOwnshipTime!) >
            const Duration(seconds: 5)) {
      _gpsRequestInProgress = true;
      print('[GPS] Fallback triggered, getting phone location');

      try {
        print('[GPS] About to call _location.getLocation()...');

        // Use simpler location request with timeout
        final locationData = await _location.getLocation().timeout(
          const Duration(seconds: 5),
          onTimeout: () {
            print('[GPS] getLocation() TIMED OUT after 5 seconds');
            throw TimeoutException('Location request timed out');
          },
        );

        print('[GPS] getLocation() returned successfully');
        print('[GPS] Got location: lat=${locationData.latitude}, '
            'lon=${locationData.longitude}, '
            'alt=${locationData.altitude}, '
            'heading=${locationData.heading}');

        if (locationData.latitude != null && locationData.longitude != null) {
          if (mounted) {
            setState(() {
              _ownshipState = OwnshipState.fromPhoneGPS(
                latitude: locationData.latitude!,
                longitude: locationData.longitude!,
                altitude: locationData.altitude,
                heading: locationData.heading,
              );
              _usingGpsFallback = true;
            });
            print('[GPS] Ownship set from GPS: ${_ownshipState?.position}');
          }
        } else {
          print('[GPS] Location data missing lat/lon');
        }
      } catch (e, stackTrace) {
        print('[GPS] ERROR getting location: $e');
        print('[GPS] Stack trace: $stackTrace');

        // In debug mode, fallback to Heck Field (YHEC) if GPS fails
        // This handles iOS simulator where location services don't work
        if (mounted) {
          const bool isDebug = !bool.fromEnvironment('dart.vm.product');
          if (isDebug) {
            print('[GPS] Debug mode: Using Heck Field (YHEC) as fallback');
            setState(() {
              _ownshipState = OwnshipState.fromPhoneGPS(
                latitude: -27.7667,
                longitude: 153.3372,
                altitude: 500.0, // Approximate field elevation
                heading: null,
              );
              _usingGpsFallback = true;
            });
            print('[GPS] Ownship set to Heck Field: ${_ownshipState?.position}');
          }
        }
      } finally {
        _gpsRequestInProgress = false;
      }
    } else {
      print('[GPS] Not triggering fallback yet (last ownship was recent)');
    }
  }

  @override
  Widget build(BuildContext context) {
    // App bar color based on connection status
    final appBarColor = _isConnected
        ? Colors
              .green
              .shade600 // Green when receiving data
        : Colors.grey.shade700; // Grey when disconnected

    final statusText = _isConnected
        ? 'GDL90 - RECEIVING'
        : 'GDL90 - DISCONNECTED';

    return Scaffold(
      appBar: AppBar(
        title: Text(
          statusText,
          style: const TextStyle(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        backgroundColor: appBarColor,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: Stack(
        children: [
          _buildMap(),
          _buildHeartbeatIndicator(),
        ],
      ),
    );
  }

  Widget _buildHeartbeatIndicator() {
    // Check if heartbeat is stale (>5 seconds since last)
    final now = DateTime.now();
    final isStale = _lastHeartbeatTime == null ||
        now.difference(_lastHeartbeatTime!) > const Duration(seconds: 5);

    final bgColor = isStale ? Colors.red : Colors.green.shade700;
    final text = isStale ? 'NO HEARTBEAT' : 'HEARTBEAT OK';

    return Positioned(
      top: 0,
      left: 0,
      right: 0,
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        color: bgColor,
        child: Text(
          text,
          style: const TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
            fontSize: 12,
          ),
          textAlign: TextAlign.center,
        ),
      ),
    );
  }

  Widget _buildMap() {
    return AppleMap(
      initialCameraPosition: const CameraPosition(
        target: LatLng(-27.7667, 153.3372), // Heck Field (YHEC) default
        zoom: 10,
      ),
      onMapCreated: (controller) {
        _mapController = controller;
      },
      annotations: _buildAnnotations(),
      mapType: MapType.standard,
      myLocationEnabled: false, // We'll draw our own ownship marker
      myLocationButtonEnabled: false,
    );
  }

  Set<Annotation> _buildAnnotations() {
    final annotations = <Annotation>{};
    final now = DateTime.now();

    // Remove stale traffic (>15 seconds old)
    _trafficTargets.removeWhere((icao, target) {
      final isStale = now.difference(target.lastUpdate).inSeconds > 15;
      if (isStale) {
        print('[TRAFFIC] Removed stale target: $icao');
      }
      return isStale;
    });

    // Add ownship marker (always show, whether from GDL90 or GPS fallback)
    if (_ownshipState != null) {
      final ownshipPos = _ownshipState!.position;

      if (ownshipPos != null) {
        final heading = _ownshipState!.heading ?? 0;

        // Create arrow icon asynchronously
        _createArrowIcon(
          heading: heading,
          color: Colors.green,
          isOwnship: true,
        ).then((icon) {
          if (mounted) {
            setState(() {
              // Icon is now cached, will be used on next rebuild
            });
          }
        });

        // Use cached icon if available, otherwise use default temporarily
        final icon = _ownshipIcons[heading] ??
            BitmapDescriptor.markerAnnotationWithHue(
              BitmapDescriptor.hueGreen,
            );

        annotations.add(
          Annotation(
            annotationId: AnnotationId('ownship'),
            position: ownshipPos,
            icon: icon,
            infoWindow: InfoWindow(
              title: _usingGpsFallback ? 'Ownship (GPS)' : 'Ownship',
              snippet: _usingGpsFallback
                  ? 'GPS: ${_ownshipState!.altitude ?? 0}ft, hdg: $heading°'
                  : 'GDL90: ${_ownshipState!.altitude ?? 0}ft, hdg: $heading°',
            ),
          ),
        );
      }
    }

    // Add traffic markers
    for (final target in _trafficTargets.values) {
      // Create arrow icon asynchronously
      _createArrowIcon(
        heading: target.heading,
        color: Colors.red,
        isOwnship: false,
      ).then((icon) {
        if (mounted) {
          setState(() {
            // Icon is now cached, will be used on next rebuild
          });
        }
      });

      // Use cached icon if available, otherwise use default temporarily
      final icon = _trafficIcons[target.heading] ??
          BitmapDescriptor.markerAnnotationWithHue(
            BitmapDescriptor.hueRed,
          );

      annotations.add(
        Annotation(
          annotationId: AnnotationId('traffic-${target.icao}'),
          position: target.position,
          icon: icon,
          infoWindow: InfoWindow(
            title: target.callsign,
            snippet:
                '${target.altitude}ft (${target.relativeAltitude}), hdg: ${target.heading}°',
          ),
        ),
      );
    }

    return annotations;
  }

  /// Create a rotated arrow icon for the given heading and color.
  ///
  /// Returns a BitmapDescriptor with an arrow pointing in the direction of heading.
  Future<BitmapDescriptor> _createArrowIcon({
    required int heading,
    required Color color,
    required bool isOwnship,
  }) async {
    // Check cache first
    final cache = isOwnship ? _ownshipIcons : _trafficIcons;
    if (cache.containsKey(heading)) {
      return cache[heading]!;
    }

    // Create a canvas to draw the arrow
    final size = 60.0;
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // Draw arrow pointing up (will be rotated)
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final outlinePaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    // Save canvas state
    canvas.save();

    // Move to center and rotate
    canvas.translate(size / 2, size / 2);
    canvas.rotate(heading * (3.14159 / 180.0)); // Convert degrees to radians

    // Draw arrow shape (pointing up when rotation is 0)
    final path = Path()
      ..moveTo(0, -size / 3) // Tip
      ..lineTo(-size / 6, size / 6) // Bottom left
      ..lineTo(-size / 12, size / 6) // Inner left
      ..lineTo(-size / 12, size / 3) // Tail left
      ..lineTo(size / 12, size / 3) // Tail right
      ..lineTo(size / 12, size / 6) // Inner right
      ..lineTo(size / 6, size / 6) // Bottom right
      ..close();

    // Draw outline
    canvas.drawPath(path, outlinePaint);
    // Draw fill
    canvas.drawPath(path, paint);

    // Restore canvas
    canvas.restore();

    // Convert to image
    final picture = recorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final bytes = await image.toByteData(format: ui.ImageByteFormat.png);

    // Create BitmapDescriptor
    final descriptor = BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());

    // Cache it
    cache[heading] = descriptor;

    return descriptor;
  }
}
